const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=(r,n)=>{let{steps:a,context:o,preReset:s}={steps:[],context:{},preReset:()=>null,...n||{}};if(!Array.isArray(a)||a.length<2)throw new TypeError(`${r}: expecting array of at least 2 steps configs.`);const c=(e,t)=>"function"==typeof e[t]?e[t]:()=>!0;let i=0;const u=a.length-1;let l=[];const p=()=>({steps:a,step:a[i],context:o}),x=(e=null)=>{if(!0===e)return g.set(p()),i;let{data:t,error:r,canGoNext:n}=e||{},s=0;return void 0!==t&&a[i].data!==t&&(a[i].data=t,s++),void 0!==r&&a[i].error!==r&&(a[i].error=r,s++),n=!!n,void 0!==n&&a[i].canGoNext!==n&&(a[i].canGoNext=n,s++),void 0!==e?.context&&e.context!==o&&(o=e.context,s++),s&&g.set(p()),i},d=e=>x({data:e}),f=e=>x({error:e}),b=e=>x({context:e}),h=(e=!0)=>x({canGoNext:e}),w=async(e=null)=>y.isDone()?i:(a[i].data={...l[i],...a[i].data||{},...e||{}},a[i].error=null,await a[i].preNext(a[i].data,{context:o,wizard:y,setData:d,setError:f,setContext:b,setCanGoNext:h,touch:x}),a[i].canGoNext?(i=Math.min(u,i+1),a[i].error=null):a[i].error||="Cannot proceed. Check your step state and/or `canGoNext` flag.",x(!0)),N=async()=>(await a[i].prePrevious(a[i].data,{context:o,wizard:y,setData:d,setError:f,setContext:b,setCanGoNext:h,touch:x}),i=Math.max(0,i-1),x(!0));a=a.map(((e,t)=>{const r=e.data||{};return l[t]=(e=>JSON.parse(JSON.stringify(e)))(r),{...e,label:e.label||`${t+1}`,index:t,data:r,canGoNext:void 0===e.canGoNext||!!e.canGoNext,error:null,isFirst:0===t,isLast:t===u,preNext:c(e,"preNext"),prePrevious:c(e,"prePrevious"),preReset:c(e,"preReset"),setData:d,setError:f,setContext:b,setCanGoNext:h,touch:x,next:w,previous:N}}));const g=((r=undefined,n=null)=>{const a=t=>e(n?.persist)&&n.persist(t);let o=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r={})=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const n=r(e,(e=>{t(e),n()}));return n},unsubscribeAll:t=>e.delete(t)}})(),s=r;a(s);const c=()=>s,i=e=>{s!==e&&(s=e,a(s),o.publish("change",s))};return{set:i,get:c,update:e=>{t(e,"[update]"),i(e(c()))},subscribe:e=>(t(e,"[subscribe]"),e(s),o.subscribe("change",e))}})(p()),y={get:g.get,subscribe:g.subscribe,next:w,previous:N,reset:async()=>{for(let e=i;e>=0;e--)i=e,await a[i].preReset(a[i].data,{context:o,wizard:y,setData:d,setError:f,setContext:b,setCanGoNext:h,touch:x});return await s({context:o,wizard:y}),l.forEach(((e,t)=>{a[t].data=e,a[t].error=null})),x(!0),i},goto:async(e,t=[])=>{if(e<0||e>u)return`Invalid step index ${e}`;if(e!==i){if(e<i)for(let t=i;t>e;t--)await N();else for(let r=i;r<=e;r++)if(await w(t[r]),a[r].error)return r;return i}},isDone:()=>i===u};return y};export{r as createWizardStore};
