const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=(r,n)=>{let{steps:s,context:a,preReset:o}={steps:[],context:{},preReset:()=>null,...n||{}};if(!Array.isArray(s)||s.length<2)throw new TypeError(`${r}: expecting array of at least 2 steps configs.`);const i=(e,t)=>"function"==typeof e[t]?e[t]:()=>!0;let c=0;const u=s.length-1;let l=[],p=[];const d=[],f=()=>({steps:s,step:s[c]}),x=(e=null)=>{if(!0===e)return g.set(f()),c;let{data:t,error:r,canGoNext:n}=e||{};n=!!n;let a=0;return Object.entries({data:t,error:r,canGoNext:n}).forEach((([e,t])=>{void 0!==t&&s[c][e]!==t&&(s[c][e]=t,a++)})),a&&g.set(f()),c},b=async(e=null)=>h.isDone()?c:(s[c].data={...l[c],...s[c].data||{},...e||{}},s[c].error=null,await d[c].preNext(s[c].data,{context:a,wizard:h,set:x}),s[c].canGoNext?(c=Math.min(u,c+1),s[c].error=null):s[c].error||="Cannot proceed. Check your step state and/or `canGoNext` flag.",x(!0)),w=async()=>(await d[c].prePrevious(s[c].data,{context:a,wizard:h,set:x}),c=Math.max(0,c-1),x(!0));s=s.map(((e,t)=>{const r=e.data||{},n=void 0===e.canGoNext||!!e.canGoNext;return l[t]=(e=>JSON.parse(JSON.stringify(e)))(r),p[t]=n,d[t]={preNext:i(e,"preNext"),prePrevious:i(e,"prePrevious"),preReset:i(e,"preReset")},{...e,label:e.label||`${t+1}`,index:t,data:r,canGoNext:n,error:null,isFirst:0===t,isLast:t===u,set:x,next:b,previous:w}}));const g=((r=undefined,n=null)=>{const s=t=>e(n?.persist)&&n.persist(t);let a=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r={})=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const n=r(e,(e=>{t(e),n()}));return n},unsubscribeAll:t=>e.delete(t)}})(),o=r;s(o);const i=()=>o,c=e=>{o!==e&&(o=e,s(o),a.publish("change",o))};return{set:c,get:i,update:e=>{t(e,"[update]"),c(e(i()))},subscribe:e=>(t(e,"[subscribe]"),e(o),a.subscribe("change",e))}})(f()),h={get:g.get,subscribe:g.subscribe,context:a,next:b,previous:w,reset:async()=>{for(let e=c;e>=0;e--)c=e,await d[c].preReset(s[c].data,{context:a,wizard:h,set:x});return await o({context:a,wizard:h}),l.forEach(((e,t)=>{s[t].data=e,s[t].error=null,s[t].canGoNext=p[t]})),x(!0),c},goto:async(e,t=[])=>{if(e<0||e>u)return`Invalid step index ${e}`;if(e!==c){if(e<c)for(let t=c;t>e;t--)await w();else for(let r=c;r<=e;r++)if(await b(t[r]),s[r].error)return r;return c}},isDone:()=>c===u};return h};export{r as createWizardStore};
