const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=(r,s)=>{let{steps:n,context:o,preReset:a,onDone:i}={steps:[],context:{},preReset:()=>null,onDone:()=>null,...s||{}};if(!Array.isArray(n)||n.length<2)throw new TypeError(`${r}: expecting array of at least 2 steps configs.`);const c=(e,t)=>"function"==typeof e[t]?e[t]:()=>!0;let l=0;const u=n.length-1;let p=[],d=[];const f=[];let x=!1;const g=()=>({steps:n,step:n[l],inProgress:x}),b=(e=null)=>{if(!0===e)return y.set(g()),l;let{data:t,error:r,canGoNext:s}=e||{};void 0!==s&&(s=!!s);let o=0;return Object.entries({data:t,error:r,canGoNext:s}).forEach((([e,t])=>{void 0!==t&&n[l][e]!==t&&(n[l][e]=t,o++)})),void 0!==e.inProgress&&e.inProgress!==x&&(x=e.inProgress,o++),o&&y.set(g()),l},w=async(e=null)=>{n[l].data={...p[l],...n[l].data||{},...e||{}},n[l].error=null,b({inProgress:!0}),await f[l].preNext(n[l].data,{context:o,wizard:P,set:b});let t=!1;if(n[l].canGoNext){if(t=n[l].isLast,l=Math.min(u,l+1),n[l].error=null,t)try{await i({context:o,steps:n,wizard:P,set:b})}catch(e){n[l].error=e}}else n[l].error||=`Step (${l}): Cannot proceed.`;return b({inProgress:!1})},h=async()=>(b({inProgress:!0}),await f[l].prePrevious(n[l].data,{context:o,wizard:P,set:b}),l=Math.max(0,l-1),b({inProgress:!1}));n=n.map(((e,t)=>{const r=e.data||{},s=void 0===e.canGoNext||!!e.canGoNext;return p[t]=(e=>JSON.parse(JSON.stringify(e)))(r),d[t]=s,f[t]={preNext:c(e,"preNext"),prePrevious:c(e,"prePrevious"),preReset:c(e,"preReset")},{...e,label:e.label||`${t+1}`,index:t,data:r,canGoNext:s,error:null,isFirst:0===t,isLast:t===u,set:b,next:w,previous:h}}));const y=((r=undefined,s=null)=>{const n=t=>e(s?.persist)&&s.persist(t);let o=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r={})=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const s=r(e,(e=>{t(e),s()}));return s},unsubscribeAll:t=>e.delete(t)}})(),a=r;n(a);const i=()=>a,c=e=>{a!==e&&(a=e,n(a),o.publish("change",a))};return{set:c,get:i,update:e=>{t(e,"[update]"),c(e(i()))},subscribe:e=>(t(e,"[subscribe]"),e(a),o.subscribe("change",e))}})(g()),P={get:y.get,subscribe:y.subscribe,context:o,next:w,previous:h,reset:async()=>{b({inProgress:!0});for(let e=l;e>=0;e--)l=e,await f[l].preReset(n[l].data,{context:o,wizard:P,set:b});return await a({context:o,wizard:P}),p.forEach(((e,t)=>{n[t].data=e,n[t].error=null,n[t].canGoNext=d[t]})),b({inProgress:!1}),l},goto:async(e,t=[])=>{if(e<0||e>u)return`Invalid step index ${e}`;if(e!==l){if(e<l)for(let t=l;t>e;t--)await h();else for(let r=l;r<=e;r++)if(await w(t[r]),n[r].error)return r;return l}}};return P};export{r as createWizardStore};
