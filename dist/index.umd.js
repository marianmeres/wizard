!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).wizard={})}(this,(function(e){"use strict";const r=e=>"function"==typeof e,t=(e,t="")=>{if(!r(e))throw new TypeError(`${t} Expecting function arg`.trim())};e.createWizardStore=(e,o)=>{let{steps:n,context:s,preReset:i,onDone:a}={steps:[],context:{},preReset:()=>null,onDone:()=>null,...o||{}};if(!Array.isArray(n)||n.length<2)throw new TypeError(`${e}: expecting array of at least 2 steps configs.`);const c=(...e)=>{"function"==typeof o.logger&&o.logger.apply(o.logger,e)};let l=!1;const p=(e,r)=>{const t="function"==typeof e[r]?e[r]:()=>!0;return async(e,{context:r,set:o,wizard:n})=>{l=!0;try{await t(e,{context:r,set:o,wizard:n})}catch(e){throw e}finally{l=!1}}};let d=0;const u=n.length-1;let f=[],g=[];const x=[];let w=!1;const h=()=>({steps:n,step:n[d],inProgress:w}),y=(e,r)=>{if(c(`  _set(${e})`,r),!0===r)return m.set(h()),e;let{data:t,error:o,canGoNext:s}=r||{};void 0!==s&&(s=!!s);let i=0;return Object.entries({data:t,error:o,canGoNext:s}).forEach((([r,t])=>{void 0!==t&&n[e][r]!==t&&(n[e][r]=t,i++)})),void 0!==r.inProgress&&r.inProgress!==w&&(w=r.inProgress,i++),i&&m.set(h()),e},b=(e=null)=>(c("set() ..."),y(d,e)),N=async(e=null)=>{c("next() ...",{current:d});const r=d;n[r].data={...f[r],...n[r].data||{},...e||{}},n[r].error=null,y(r,{inProgress:!0});try{await x[r].preNext(n[r].data,{context:s,wizard:v,set:b})}catch(e){n[r].error=e,c(`  error in next:preNext(${r})`,e.toString())}if(n[r].canGoNext||(n[r].error||=[`Step (${r}): Cannot proceed.`,"(Hint: check if the 'canGoNext' step prop is re/set correctly)"].join(" ")),!n[r].error&&n[r].isLast)try{await a({context:s,steps:n,wizard:v,set:b})}catch(e){n[r].error=e,c("  error in next:onDone()",{current:r},e.toString())}return y(r,{inProgress:!1}),n[r].error||(d=Math.min(u,d+1),c(`  ... incremented pointer to ${d}`),n[d].error=null),b(!0)},$=async()=>{c("previous() ...",{current:d});const e=d;y(e,{inProgress:!0});try{await x[e].prePrevious(n[e].data,{context:s,wizard:v,set:b})}catch(r){n[e].error=r,c("  error in previous()",{current:e},r.toString())}return y(e,{inProgress:!1}),d=Math.max(0,d-1),c(`  ... decremented pointer to ${d}`),b(!0)};n=n.map(((e,r)=>{const t=e.data||{},o=void 0===e.canGoNext||!!e.canGoNext;return f[r]=(e=>JSON.parse(JSON.stringify(e)))(t),g[r]=o,x[r]={preNext:p(e,"preNext"),prePrevious:p(e,"prePrevious"),preReset:p(e,"preReset")},{...e,label:e.label||`${r+1}`,index:r,data:t,canGoNext:o,error:null,isFirst:0===r,isLast:r===u,next:N,previous:$,set:(e=null)=>{c("step.set() ..."),y(r,e)}}}));const m=((e,o=null)=>{const n=e=>r(o?.persist)&&o.persist(e);let s=(()=>{const e=new Map,r=r=>(e.has(r)||e.set(r,new Set),e.get(r)),t=(e,t)=>{if("function"!=typeof t)throw new TypeError("Expecting callback function as second argument");return r(e).add(t),()=>r(e).delete(t)};return{publish:(e,t={})=>{r(e).forEach((e=>e(t)))},subscribe:t,subscribeOnce:(e,r)=>{const o=t(e,(e=>{r(e),o()}));return o},unsubscribeAll:r=>e.delete(r)}})(),i=e;n(i);const a=()=>i,c=e=>{i!==e&&(i=e,n(i),s.publish("change",i))};return{set:c,get:a,update:e=>{t(e,"[update]"),c(e(a()))},subscribe:e=>(t(e,"[subscribe]"),e(i),s.subscribe("change",e))}})(h()),v={get:m.get,subscribe:m.subscribe,context:s,next:N,previous:$,reset:async()=>{if(c("reset() ...",{current:d}),l)throw new TypeError('Cannot reset wizard state from inside of "pre" handlers.');for(let e=d;e>=0;e--)try{d=e,y(e,{inProgress:!0}),await x[e].preReset(n[e].data,{context:s,wizard:v,set:b})}catch(r){c(`  swallowed error inside reset loop (preReset(${e}))`,r.toString())}finally{y(e,{inProgress:!1})}try{await i({context:s,wizard:v})}catch(e){c("  swallowed error inside global preReset()",e.toString())}return f.forEach(((e,r)=>{n[r].data=e,n[r].error=null,n[r].canGoNext=g[r]})),b(!0)},goto:async(e,r=[],t=!0)=>{if(c(`goto(${e}) ...`,{current:d}),e<0||e>u)throw new RangeError(`Invalid step index ${e}`);if(e===d)return;let o,s;if(e<d){for(let r=d;r>e;r--)if(o=await $(),n[r].error){c(`  error detected in goto back loop (index ${r})`,n[r].error),s=r;break}}else for(let t=d;t<e;t++)if(o=await N(r[t]),n[t].error){c(`  error detected in goto forward loop (index ${t})`,n[t].error),s=t;break}if(t&&void 0!==s)throw new Error([`The 'goto(${e}, ...)' command did not succeed.`,`Check step[${s}]'s error.`].join(" "));return o},label:e,allowCanGoNext:()=>(n=n.map(((e,r)=>({...e,canGoNext:!0}))),b(!0)),resetCanGoNext:()=>(n=n.map(((e,r)=>({...e,canGoNext:g[r]}))),b(!0))};return v}}));
