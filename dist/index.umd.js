!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).wizard={})}(this,(function(e){"use strict";const r=e=>"function"==typeof e,t=(e,t="")=>{if(!r(e))throw new TypeError(`${t} Expecting function arg`.trim())},n=e=>"function"==typeof e;e.createWizardStore=function(e,o){let{steps:s,context:i,preReset:a,onDone:c}={steps:[],context:{},preReset:()=>null,onDone:()=>null,...o||{}};if(!Array.isArray(s)||s.length<2)throw new TypeError(`${e}: expecting array of at least 2 steps configs.`);const l=(...e)=>{n(o.logger)&&o.logger.apply(o.logger,e)};let p=!1;const d=(e,r)=>{const t=n(e[r])?e[r]:()=>!0;return async(e,{context:r,set:n,wizard:o})=>{p=!0;try{await t(e,{context:r,set:n,wizard:o})}catch(e){throw e}finally{p=!1}}};let u=0;const f=s.length-1;let g=[],x=[];const w=[];let h=!1;const b=()=>({steps:s,step:s[u],inProgress:h}),y=(e,r)=>{if(l(`  _set(${e})`,r),!0===r)return m.set(b()),e;let{data:t,error:o,canGoNext:i}=r||{};void 0!==i&&(i=!!i);let a=0;return Object.entries({data:t,error:o,canGoNext:i}).forEach((([r,t])=>{void 0===t||s[e][r]===t&&!n(t)||(n(t)&&(t=t(s[e][r])),s[e][r]!==t&&(s[e][r]=t,a++))})),void 0!==r.inProgress&&r.inProgress!==h&&(h=r.inProgress,a++),a&&m.set(b()),e},N=(e=null)=>(l("set() ..."),y(u,e)),v=async(e=null)=>{l("next() ...",{current:u});const r=u;s[r].data={...g[r],...s[r].data||{},...e||{}},s[r].error=null,y(r,{inProgress:!0});try{await w[r].preNext(s[r].data,{context:i,wizard:E,set:N})}catch(e){s[r].error=e,l(`  error in next:preNext(${r})`,e.toString())}if(s[r].canGoNext||(s[r].error||=[`Step (${r}): Cannot proceed.`,"(Hint: check if the 'canGoNext' step prop is re/set correctly)"].join(" ")),!s[r].error&&s[r].isLast)try{await c({context:i,steps:s,wizard:E,set:N})}catch(e){s[r].error=e,l("  error in next:onDone()",{current:r},e.toString())}return y(r,{inProgress:!1}),s[r].error||(u=Math.min(f,u+1),l(`  ... incremented pointer to ${u}`),s[u].error=null),N(!0)},$=async()=>{l("previous() ...",{current:u});const e=u;y(e,{inProgress:!0});try{await w[e].prePrevious(s[e].data,{context:i,wizard:E,set:N})}catch(r){s[e].error=r,l("  error in previous()",{current:e},r.toString())}return y(e,{inProgress:!1}),u=Math.max(0,u-1),l(`  ... decremented pointer to ${u}`),N(!0)};s=s.map(((e,r)=>{const t=e.data||{},n=void 0===e.canGoNext||!!e.canGoNext;return g[r]=(e=>JSON.parse(JSON.stringify(e)))(t),x[r]=n,w[r]={preNext:d(e,"preNext"),prePrevious:d(e,"prePrevious"),preReset:d(e,"preReset")},{...e,label:e.label||`${r+1}`,index:r,data:t,canGoNext:n,error:null,isFirst:0===r,isLast:r===f,next:v,previous:$,set:(e=null)=>{l("step.set() ..."),y(r,e)}}}));const m=((e,n=null)=>{const o=e=>r(null==n?void 0:n.persist)&&n.persist(e);let s=(()=>{const e=new Map,r=r=>(e.has(r)||e.set(r,new Set),e.get(r)),t=(e,t)=>{if(!e)throw new TypeError("Expecting valid event name.");if("function"!=typeof t)throw new TypeError("Expecting valid callback function.");return r(e).add(t),()=>r(e).delete(t)};return{publish:(e,t)=>{r(e).forEach((e=>e(t)))},subscribe:t,subscribeOnce:(e,r)=>{const n=t(e,(e=>{r(e),n()}));return n},unsubscribe:(e,t)=>{r(e).delete(t)},unsubscribeAll:r=>e.delete(r)}})(),i=e;o(i);const a=()=>i,c=e=>{i!==e&&(i=e,o(i),s.publish("change",i))};return{set:c,get:a,update:e=>{t(e,"[update]"),c(e(a()))},subscribe:e=>(t(e,"[subscribe]"),e(i),s.subscribe("change",e))}})(b()),E={get:m.get,subscribe:m.subscribe,context:i,next:v,previous:$,reset:async()=>{if(l("reset() ...",{current:u}),p)throw new TypeError('Cannot reset wizard state from inside of "pre" handlers.');for(let e=u;e>=0;e--)try{u=e,y(e,{inProgress:!0}),await w[e].preReset(s[e].data,{context:i,wizard:E,set:N})}catch(r){l(`  swallowed error inside reset loop (preReset(${e}))`,r.toString())}finally{y(e,{inProgress:!1})}try{await a({context:i,wizard:E})}catch(e){l("  swallowed error inside global preReset()",e.toString())}return g.forEach(((e,r)=>{s[r].data=e,s[r].error=null,s[r].canGoNext=x[r]})),N(!0)},goto:async(e,r=[],t=!0)=>{if(l(`goto(${e}) ...`,{current:u}),e<0||e>f)throw new RangeError(`Invalid step index ${e}`);if(e===u)return;let n,o;if(e<u){for(let r=u;r>e;r--)if(n=await $(),s[r].error){l(`  error detected in goto back loop (index ${r})`,s[r].error),o=r;break}}else for(let t=u;t<e;t++)if(n=await v(r[t]),s[t].error){l(`  error detected in goto forward loop (index ${t})`,s[t].error),o=t;break}if(t&&void 0!==o)throw new Error([`The 'goto(${e}, ...)' command did not succeed.`,`Check step[${o}]'s error.`].join(" "));return n},label:e,allowCanGoNext:()=>(s=s.map(((e,r)=>({...e,canGoNext:!0}))),N(!0)),resetCanGoNext:()=>(s=s.map(((e,r)=>({...e,canGoNext:x[r]}))),N(!0))};return E}}));
